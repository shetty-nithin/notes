1. Data Types of the variable can change during the runtime. Thats why we call it as Dynamic Programming.
2. Data Types in JS
	Primitive
	i. string
	ii. number
	iii. null
	iv. undefined
	v. bool
	vi. big
	vii. symbol

	Non-Primitive
	i. Object

3. What is undefined?
	A variable has been declared, but havent assigned any value.
4. Null is an intensional absence of data.
5. Java Script Hoisting
	It is mechanism, where variable and function declaration are 
	move to the top of the scope before the code executes.
	
6. Global variables : Which is accessilbe throughout the page. 
			    It can make code very hard to debug.
7. What if we declare a varialbe without the "var" keyword?
	Variable becomes Golbal.
8. What is the use of "use strict" keyword?
	It checks if the variable is defined using the var keyword or 
	let keyword. It throws if not.
9. How to Global variable in the project?
	We cannot avoid Global variable, we can avoid Global variables.
	i. We can put GV in a proper common namespace.
		ex: var global = {};
		    global.one = ...
		    global.tow = ...
	ii. Create a closure and apply module pattern
		
10. What is Closure?
	Closures are statefull function. Its a function inside a function.
	And it makes normal function stateful.
	ex: 
	function SimpleFunction(){
		var x = 0;
		x++;
	}
	function ClosureFunction(){
		var x = 0;
		function Increment(){
			x++;
		}
		function GetValue(){
			return x;
		}
		function init(){

		}
		init();
		return {
			Increment,
			GetValue
		}
	}

	SimpleFunction();
	SimpleFunction();
	// in both of the above cases value of the x = 1;
	// because it doesnt remeber the state of the x;

	var ref = ClosureFunction(); // holding the reference
	ref.Increment(); // x = 1
	ref.Increment(); // x = 2

11. What is the need of Closure?
	The only goal of closure is to Create	
		i. self contained functions
		ii. self contained code
		iii. self contained module.
	And when we create self contained, we have self contained state,
	this means it helps us to avoid global varibles.
	And also it helps in exposing what we want to expose.(abstraction)

12. What is IIFE?
	IIFE : Immediately Invoked Function Expression
	Its an anonymous function.
	ex:
		(function(){

		})();
13. What is the use of IIFE, What is name collision in global scope
	and IIFE vs Normal Function?
	
	i. Name Collision: It happens when we name the same function/
	variable name to mpre the one function/variable in the same
	context.

	ii. Use of IIFE : To avoid name collision.

14. What are design patterns?
	Design patterns are timt tested architecture.
		i. Singleton pattern.
		ii. module design pattern(populare one):
			IIFE + Closure
			better code management because of IIFE nad 
			better encapsulation because of Closure

15. Ways of create a js object.
	i. Literal
		ex: var pat = {"a":"", "b":""};
			pat.Admit = function(){}
	
	ii. Object.create
		ex:	var patnew = Object.create(pat);
			patnew.age = 10;

	iii. Constructor Way
		ex:	function Patient(){
			this.name = "",
			this.address = "",
			ths.Admit = function(){}
		}

		var pat1 = new Patient();

	iv. ES6 Classes
		class PatientClass{
			constructor(name, address){
				this.name="",
				this.address=""
			}
		}
		var p = new PatientClass();

16. How to do Inheritance? What is prototype object?
	Explain prototype chaining.
	
	Inheritance in js is done by prototype object.
	we have object inheritance and not class inheritance 
	and happens through prototype object

	ex:
		function Employee(){
			this.name="",
			this.DoWork=function(){},
			this.attendence=function(){}
		}
		function Manager(){
			this.Cabin="",
			this.DoWork=function(){}
		}

		var emp = new Employee();
		Manager.prototype = emp // it means manager is a child of employee

		var man = new Manager();
		man.Name = "Shiv";
		man.attendence();
		man.DoWork();

	Every JS object has a prototype object.
	Prototype Object works like a linkedlist, thats why
	its called as Prototype Chaining.

17. Explain let keyword.
	It helps in creating block level scopped variable.

18. Var will be hoisted and initialized with the value "undefined".
	Let will be hoisted, but will not be assigned with any value.

19. Temporal Dead Zone.
	It is the period between when the variable is named in the 
	memory but not declared and initialized with the value
	and the initialization.

20. 
	var d = "10"
	var d1 = "10"
	console.log(d+d1) // 1010

	var i = 10;
	var i1 = 10;
	console.log(i+i1) // 20

	console.log(1+1+"4") // 24


---------------------------------
Namaste JS

1. Everything in JS executes inside the Execution context.
	Memory Component : variable and function will store in key value pair.
	This is also called as "Variable Environment"

	Code Component : Code will executes one line at a time.
	This is also known as "thread of execution"

2. JS is single synchronous threaded language:
	i. It means it can executes only one line at a time.
	ii. and it can go to the next line only when the completion of 
	current line

3. Lexical Environment: if the value is not present in the scope,
	it goes outside of the function find the value of the variable.

4. Function statement/declaration:
	function a(){};

   Function Expression:
	var a = function(){};

	Diff: Hoisting

5. Sending / recieving a function as a value is called as first class function.

6. Event loop, callstack, callback queue and micro

7. Higher order function : Function which takes the function as a parameter.
